<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>AllenNLP Configuration Wizard (alpha)</title>
    <style>
        div {
            display: table;
        }

        * {
            font-family: sans-serif;
        }

        h1,
        h2 {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            font-weight: 300
        }

        h2 {
            font-size: 2em;
        }

        .optional {
            color: gray;
        }

        .required {
            color: black;
        }

        span.name {
            font-weight: bold;
            margin: 5px;
        }

        div.dict-or-list-item {
            margin: 5px;
        }

        .required.incomplete > span.name {
            background-color: lightcoral;
        }

        .annotation {
            font-size: 90%;
            margin-left: 10px;
            margin-right: 10px;
            color: #2085bc;
        }

        .prefix {
            font-size: 75%;
            margin-left: 10px;
        }


        .default-value {
            color: #979a9d;
            font-size: 90%;
        }

        div#rendered-json {
            margin: 10px;
            border: 1px solid black;
            font-family: monospace;
            white-space: pre;
        }

        .config, .list, .dict {
            margin-top: 5px;
            margin-left: 40px;
        }

        .config-item {
            margin-top: 2px;
        }

        button.subconfigure {
            margin: 2px;
        }

        .tippy-content {
            color: white;
        }
    </style>
  </head>
  <body>
    <h2>AllenNLP Configuration Wizard (alpha)</h2>

    <div id="app"></div>

    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/immutable/3.8.2/immutable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.26.0/babel.js"></script>
    <script src="https://unpkg.com/tippy.js@2.5.2/dist/tippy.all.min.js"></script>
    <script type="text/babel">
/*
ConfigItem = {
   name : str
   annotation : List[str]
   configurable : bool
   defaultValue : str
   comment : str

Config = {
    type: str
    items: List[ConfigItem]
}

ApiResponse = {
    className: str
    config: Config
} or {
    className: str
    choices: Dict[str, str]  // name -> className
}
*/

// A configItem is optional if it has no default value
const isOptional = (configItem) => configItem.get('defaultValue') !== undefined

// Assumption is that "allennlp.*" and "torch.*" are configurable
// (at least, if they occur in a config file)
const isConfigurable = (annotation) => {
    const origin = annotation.get(0)
    return origin.startsWith('allennlp.') || origin.startsWith('torch.')
}

// Sometimes we don't have type annotations
// (e.g. for torch classes)
// and we have to best guess how to serialize an input.
const bestGuess = x => {
    const asNumber = +x

    if (x === "true") {
        return true
    } else if (x === "false") {
        return false
    } else if (!isNaN(asNumber)) {
        return asNumber
    } else {
        // Assume string
        return x
    }
}

// Recursively convert the provided value to JSON
const jsonify = (value, annotation, configurable) => {
    if (!value) {
        return undefined
    } else if (configurable) {
        return configToJson(value)
    } else {
        const origin = annotation.get(0)

        if (origin === '?') {
            return bestGuess(value)
        }
        if (origin === 'Dict') {
            const valueAnnotation = annotation.get(2)
            const configurable = isConfigurable(valueAnnotation)

            const dict = {}
            let nonEmpty = false

            value.forEach((entry) => {
                const entryKey = entry.get("key")
                const entryValue = entry.get("value")

                if (entryKey && entryKey.length && entryValue) {
                    const valueJson = jsonify(entryValue, valueAnnotation, configurable)
                    if (valueJson) {
                        nonEmpty = true
                        dict[entryKey] = valueJson
                    }
                }
            })

            return nonEmpty ? dict : undefined
        } else if (origin === 'List' || origin === 'Sequence') {
            const valueAnnotation = annotation.get(1)
            const configurable = isConfigurable(valueAnnotation)

            const list = value.map(item => jsonify(item.get('value'), valueAnnotation, configurable))
                              .filter(x => x !== undefined)
                              .toArray()

            return list.length ? list : undefined
        } else if (origin === 'int' || origin === 'float') {
            const numeric = +value
            return value.length && !isNaN(numeric) ? numeric : undefined
        } else if (origin === 'bool') {
            return {'true': true, 'false': false}[value]
        } else if (origin === 'str') {
            return value.length ? value : undefined
        } else {
            console.log("unknown type " + annotation.toJS())
            return undefined
        }
    }
}

const configToJson = (config) => {

    let blob = {}

    if (config) {
        const type = config.get('type')
        if (type) {
            blob['type'] = type
        }

        config.get('items').forEach((item) => {
            const value = item.get('value')
            const annotation = item.get('annotation')
            const configurable = item.get('configurable')

            const json = jsonify(value, annotation, configurable)

            if (json !== undefined) {
                const name = item.get('name')
                blob[name] = json
            }
        })
    }

    return blob
}

const markComplete = (config) => {
    const value = config.get('value')
    const items = config.get('items')
    const defaultValue = config.get('defaultValue')

    if (defaultValue !== undefined) {
        return config.set('completed', true)
    } else if (items) {
        const newItems = items.map(markComplete)
        const completed = newItems.every(item => item.get('completed'))
        return config.set('completed', completed).set('items', newItems)
    } else if (value) {
        // TODO: this is wrong
        return config.set('completed', true)
    } else {
        return config.set('completed', false)
    }
}

class App extends React.Component {
    constructor() {
        super()

        this.state = {
            data: Immutable.OrderedMap()
        }

        this.setData = this.setData.bind(this)
    }

    setData(fn) {
        const {data} = this.state
        const newData = fn(data).update('config', markComplete)
        console.log(newData)

        return this.setState({data: newData})
    }

    componentDidMount() {
        // Fetch the top level configuration
        fetch('/api/')
            .then(res => res.json())
            .then(config => this.setState({data: Immutable.fromJS(config)}))
    }

    render() {
        const config = this.state.data.get('config')
        return (
            <div class="wizard">
                <Config path={Immutable.List(['config'])} setData={this.setData} config={config}/>
                <JsonBox config={config}/>
            </div>
        )
    }
}

const JsonBox = ({config}) => {
    const json = configToJson(config)

    const selectAll = () => {
        window.getSelection()
              .selectAllChildren(document.getElementById('rendered-json'))
    }

    return (
        <div id="rendered-json" onClick={selectAll}>
            {JSON.stringify(json, null, 4)}
        </div>
    )
}

const Config = ({path, config, setData}) => {
    if (!config) {
        return null
    }

    const type = config.get('type')
    const items = config.get('items')
    console.log(path.toJS())

    const renderedType = type ? (
        <div class="config-item">
            <span class="name">type</span>
            <span>: {type}</span>
        </div>
    ) : null

    const renderedItems = items.map((item, idx) => {
        return <ConfigItem path={path.push('items').push(idx)} item={item} setData={setData}/>
    })

    return (
        <div class="config">
            {renderedType}
            {renderedItems}
        </div>
    )
}

const renderChild = (path, item, setData) => {
    const annotation = item.get('annotation')

    const configurable = item.get('configurable')
    const origin = annotation.get(0)

    if (configurable) {
        return <Configurator path={path} item={item} setData={setData}/>
    } else if (origin === 'Dict') {
        return <Dict path={path} item={item} setData={setData}/>
    } else if (origin === 'List' || origin == 'Sequence') {
        return <List path={path} item={item} setData={setData}/>
    } else {
        return <TextInput path={path} item={item} setData={setData}/>
    }
}

class Tooltip extends React.Component {

    componentDidMount() {
        tippy('.tooltip')
    }

    render() {
        const {title} = this.props
        return <button class="tooltip" title={title} tabIndex="-1">?</button>
    }
}

const ConfigItem = ({path, item, setData}) => {
    const name = item.get('name')
    const annotation = item.get('annotation')
    const configurable = item.get('configurable')
    const defaultValue = item.get('defaultValue')
    const comment = item.get('comment')
    const completed = item.get('completed')

    const tooltip = comment ? (
        <Tooltip title={comment}/>
    ) : null

    const classes = ['config-item']
    classes.push(defaultValue === undefined ? 'required' : 'optional')
    if (!completed) {classes.push('incomplete')}

    return (
        <div className={classes.join(' ')}>
            <span class="name">{name}</span>
            {tooltip}
            <span>:</span>
            ({annotation})
            {renderChild(path, item, setData)}
        </div>
    )
}

const Configurator = ({path, item, setData}) => {
    const annotation = item.get('annotation')
    const className = annotation.get(0)

    // User-supplied
    const choices = item.get('choices')
    const choice = item.get('choice')
    const config = item.get('value')

    const getChoices = () => {
        fetch('/api/?class=' + className)
            .then(res => res.json())
            .then(({config, choices}) => {
                if (choices) {
                    setData(oldConfig => oldConfig.setIn(path.push('choices'), Immutable.List(choices)))
                } else {
                    setData(oldConfig => oldConfig.setIn(path.push('value'), Immutable.fromJS(config)))
                }
            })
    }

    const select = (evt) => {
        const choice = evt.target.value

        fetch('/api/?class=' + choice)
            .then(res => res.json())
            .then(({config}) => {
                setData(rootConfig => rootConfig.setIn(path.push('choice'), choice)
                                                .setIn(path.push('value'), Immutable.fromJS(config)))

            })
    }

    const remove = () => {
        setData(config => config.deleteIn(path.push('choices'))
                                .deleteIn(path.push('value'))
                                .deleteIn(path.push('choice')))
    }

    const configureButton = (choices || config) ? null : <button onClick={getChoices}>+</button>
    const choicesDropdown = choices ? (
        <select value={choice} onChange={select}>
            {choice ? null : (<option value=""></option>)}
            {choices.map(subclass => <option value={subclass}>{subclass}</option>)}
        </select>
    ) : null
    const deleteButton = choice ? <button onClick={remove}>x</button> : null
    const renderedValue = config ? <Config path={path.push('value')} config={config} setData={setData}/> : null

    return <span>{configureButton}{choicesDropdown}{deleteButton}{renderedValue}</span>
}

const List = ({path, item, setData}) => {
    const annotation = item.get('annotation')
    const valueType = annotation.get(1)
    const configurable = isConfigurable(valueType)
    const items = item.get('value') || Immutable.List()

    const addItem = () => {
        const newItem = Immutable.Map({
            "annotation": valueType,
            "configurable": configurable
        })

        setData(config => config.setIn(path.push('value'), items.push(newItem)))
    }

    const removeItem = idx => () => {
        setData(config => config.setIn(path.push('value'), items.delete(idx)))
    }

    const renderedItems = items.map((item, idx) => (
        <div>
            {renderChild(path.push('value', idx), item, setData)}
            <button onClick={removeItem(idx)}>X</button>
        </div>
    ))

    return (
        <div class="list">
            {renderedItems}
            <button onClick={addItem}>+</button>
        </div>
    )
}

const Dict = ({path, item, setData}) => {
    const annotation = item.get('annotation')
    const keyType = annotation.get(1)
    const valueType = annotation.get(2)
    const configurable = isConfigurable(valueType)
    const items = item.get('value') || Immutable.List()

    const addItem = () => {
        const newItem = Immutable.Map({
            "annotation": valueType,
            "configurable": configurable
        })

        setData(config => config.setIn(path.push('value'), items.push(newItem)))
    }

    const removeItem = idx => () => {
        setData(config => config.setIn(path.push('value'), items.delete(idx)))
    }

    const renderedItems = items.map((item, idx) => (
        <div>
            <TextInput path={path.push('value', idx)} fieldName="key" item={item} setData={setData}/>
            {renderChild(path.push('value', idx), item, setData)}
            <button onClick={removeItem(idx)}>X</button>
        </div>
    ))

    return (
        <div class="dict">
            {renderedItems}
            <button onClick={addItem}>+</button>
        </div>
    )}


const TextInput = ({path, item, setData, fieldName}) => {
    fieldName = fieldName || 'value'

    const onChange = evt => {
        const value = evt.target.value
        setData(config => config.setIn(path.push(fieldName), value))
    }

    return (
        <span>
            <input type="text" value={item.get(fieldName)} onChange={onChange}/>
        </span>
    )
}

ReactDOM.render(<App />, document.getElementById("app"))

    </script>
  </body>
</html>
